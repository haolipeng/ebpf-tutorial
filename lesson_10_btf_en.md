# eBPF BTF (BPF Type Format) Programming Guide

# 1. Introduction to BTF

### What is BTF?

BTF (BPF Type Format) is a **type metadata format** provided by the Linux kernel, used to describe type information for eBPF programs and kernel data structures.

### Core Advantages of BTF

- âœ… **Compile Once, Run Everywhere (CO-RE)**: No need to recompile on target machines
- âœ… **Kernel Structure Access**: Safely read kernel data structures
- âœ… **Type Safety**: Compile-time type compatibility checking
- âœ… **Debug Friendly**: Provides rich type information

### Problems Solved by BTF

Before BTF, eBPF programs faced the following problems:

#### task_struct Structure Example (Simplified)

`task_struct` is the core data structure in the Linux kernel that describes processes. Its size and layout can differ across kernel versions.

**Example 1: task_struct in Linux 5.10 Kernel (Simplified)**

```c
struct task_struct {
    struct thread_info thread_info;    // Offset: 0    (Size: 16 bytes)
    unsigned int __state;               // Offset: 16   (Size: 4 bytes)
    void *stack;                        // Offset: 24   (Size: 8 bytes)
    refcount_t usage;                   // Offset: 32   (Size: 4 bytes)
    unsigned int flags;                 // Offset: 36   (Size: 4 bytes)
    // ... hundreds of bytes of other fields omitted ...

    pid_t pid;                          // Offset: 1232 (Size: 4 bytes) â¬…ï¸ Here!
    pid_t tgid;                         // Offset: 1236 (Size: 4 bytes)

    struct task_struct *real_parent;   // Offset: 1256 (Size: 8 bytes)
    struct task_struct *parent;         // Offset: 1264 (Size: 8 bytes)

    char comm[16];                      // Offset: 1784 (Size: 16 bytes)
    struct mm_struct *mm;               // Offset: 1848 (Size: 8 bytes)
    // ... more fields ...
};
```

**Example 2: task_struct in Linux 6.1 Kernel (Simplified)**

```c
struct task_struct {
    struct thread_info thread_info;    // Offset: 0    (Size: 16 bytes)
    unsigned int __state;               // Offset: 16   (Size: 4 bytes)
    void *stack;                        // Offset: 24   (Size: 8 bytes)
    refcount_t usage;                   // Offset: 32   (Size: 4 bytes)
    unsigned int flags;                 // Offset: 36   (Size: 4 bytes)

    // âš ï¸ Version 6.1 added some security-related fields
    unsigned int ptrace;                // Offset: 40   (New!)
    int on_rq;                          // Offset: 44   (New!)
    // ... other fields omitted ...

    pid_t pid;                          // Offset: 1368 (Size: 4 bytes) â¬…ï¸ Offset changed!
    pid_t tgid;                         // Offset: 1372 (Size: 4 bytes)

    struct task_struct *real_parent;   // Offset: 1392 (Size: 8 bytes) â¬…ï¸ Also changed!
    struct task_struct *parent;         // Offset: 1400 (Size: 8 bytes)

    char comm[16];                      // Offset: 1920 (Size: 16 bytes) â¬…ï¸ Also changed!
    struct mm_struct *mm;               // Offset: 1984 (Size: 8 bytes)
    // ... more fields ...
};
```

#### Offset Calculation Example

Suppose we want to read the `pid` field:

```c
// âŒ Wrong way: Hard-coded offsets
struct task_struct *task = (struct task_struct *)bpf_get_current_task();
int pid;

// On Linux 5.10
bpf_probe_read(&pid, sizeof(pid), (void *)task + 1232);  // pid at offset 1232

// But on Linux 6.1, the same code reads the wrong location!
bpf_probe_read(&pid, sizeof(pid), (void *)task + 1232);  // âŒ Should be 1368!
```

### BTF's Solution

```c
// BTF + CO-RE approach - Automatically handles offsets
struct task_struct *task = (struct task_struct *)bpf_get_current_task();
pid_t pid = BPF_CORE_READ(task, pid);  // âœ… Automatic adaptation!
```

**Advantages**:
- âœ… Compiler automatically calculates correct offsets
- âœ… Runtime adaptation to different kernel versions
- âœ… Type-safe access method

# 2. BTF Core Concepts

## 2.1 vmlinux.h

`vmlinux.h` is a header file containing all kernel data structure definitions, generated by `bpftool` from BTF information.

#### Generating vmlinux.h

```bash
# Generate from current kernel
bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h

# Check if kernel supports BTF
ls /sys/kernel/btf/vmlinux
```

#### Advantages of vmlinux.h

```c
// Traditional way - Need to include multiple header files
#include <linux/sched.h>
#include <linux/fs.h>
#include <linux/mm.h>
// ... potentially dozens of header files

// BTF way - Only one header file needed
#include "vmlinux.h"  // âœ… Contains all kernel definitions
```

## 2.2 BPF_CORE_READ Macro

`BPF_CORE_READ` is the core macro of CO-RE, used to **safely** read kernel structure fields.

#### Syntax Format

```c
// Basic usage
BPF_CORE_READ(ptr, field)
// Single-level access equivalent to traditional pointer access
ptr->field

// Multi-level nested access
BPF_CORE_READ(ptr, field1, field2, field3)

// Multi-level nested access equivalent to traditional pointer access
ptr->field1->field2->field3
```

#### Usage Examples

```c
struct task_struct *task = (struct task_struct *)bpf_get_current_task();

// Read single field
pid_t pid = BPF_CORE_READ(task, pid);

// Read nested field
pid_t ppid = BPF_CORE_READ(task, real_parent, pid);

// Equivalent to
// task->real_parent->pid
```

## 2.3 BPF_CORE_READ_INTO() Macro

#### BPF_CORE_READ_INTO (Read to Variable)

```c
struct task_struct *task = (struct task_struct *)bpf_get_current_task();
pid_t ppid;

// Read value into specified variable
BPF_CORE_READ_INTO(&ppid, task, real_parent, pid);
```

## 2.4 BPF_CORE_READ_STR_INTO() Macro

#### BPF_CORE_READ_STR_INTO (Read String)

```c
struct task_struct *task = (struct task_struct *)bpf_get_current_task();
char comm[16];

// Read process name
BPF_CORE_READ_STR_INTO(comm, task, comm);
```

## 2.5 bpf_probe_read vs bpf_core_read vs BPF_CORE_READ Detailed Explanation

These three are different ways to read memory data in eBPF and are easily confused. Let's compare them in detail:

#### Core Differences Overview

| Feature | bpf_probe_read | bpf_core_read | BPF_CORE_READ |
| -------------- | -------------- | --------------- | ------------- |
| **Type** | Helper function | Helper function | Macro |
| **Definition Location** | Kernel | Kernel (inline function) | libbpf header file |
| **CO-RE Support** | âŒ No | âœ… Yes | âœ… Yes |
| **Type Safety** | âŒ Weak (void *) | âœ… Strong | âœ… Strong |
| **Use Case** | Read arbitrary memory | Read single field | Read nested fields |
| **Recommendation** | â­â­ | â­â­â­ | â­â­â­â­â­ |

#### 1. bpf_probe_read - Traditional Memory Read Function

**Function Prototype**:

```c
long bpf_probe_read(void *dst, u32 size, const void *unsafe_ptr);
```

**Characteristics**:

- Lowest-level memory read function
- Requires manual size specification
- No type checking
- **Does not support CO-RE**

**Usage Example**:

```c
struct task_struct *task = (struct task_struct *)bpf_get_current_task();
struct task_struct *parent;
pid_t ppid;

// Read real_parent pointer
bpf_probe_read(&parent, sizeof(parent), &task->real_parent);

// Read parent->pid
bpf_probe_read(&ppid, sizeof(ppid), &parent->pid);
```

**Problems**:

- âŒ Need to know exact field offsets
- âŒ Nested access requires multiple calls
- âŒ No CO-RE, cannot work across kernel versions
- âŒ Verbose code

**Applicable Scenarios**:

- Reading arbitrary memory addresses (like user-space addresses)
- Scenarios unrelated to BTF/CO-RE
- Need precise control over read behavior

#### 2. bpf_core_read - CO-RE Inline Function

**Function Prototype**:

```c
static __always_inline int bpf_core_read(void *dst, int sz, const void *src);
```

**Characteristics**:

- Inline function provided by kernel
- Supports CO-RE relocation
- Requires manual size specification
- **Can only read single fields**

**Usage Example**:

```c
struct task_struct *task = (struct task_struct *)bpf_get_current_task();
pid_t pid;

// Read single field - Correct usage
bpf_core_read(&pid, sizeof(pid), &task->pid);  // âœ…

// Read nested field - Wrong usage!
// bpf_core_read(&ppid, sizeof(ppid), &task->real_parent->pid);  // âŒ Compilation error!
```

**Limitations**:

- âš ï¸ **Cannot directly access nested fields** (like `task->real_parent->pid`)
- âš ï¸ Need to manually specify size
- âš ï¸ Still relatively verbose

**Correct Nested Access Method**:

```c
// Need to read in two steps
struct task_struct *task = (struct task_struct *)bpf_get_current_task();
struct task_struct *parent;
pid_t ppid;

// Step 1: Read parent pointer
bpf_core_read(&parent, sizeof(parent), &task->real_parent);

// Step 2: Read parent->pid
bpf_core_read(&ppid, sizeof(ppid), &parent->pid);
```

**Applicable Scenarios**:

- Reading single simple fields
- Need CO-RE but don't want to use macros
- Scenarios with extreme performance requirements

#### 3. BPF_CORE_READ - Recommended CO-RE Macro â­â­â­â­â­

**Macro Definition** (Simplified):

```c
#define BPF_CORE_READ(src, a, ...)  \
({  \
    /* Record access path at compile time */  \
    /* Generate CO-RE relocation information */  \
    /* Return read value */  \
})
```

**Characteristics**:

- Macro provided by libbpf
- **Full CO-RE support**
- **Supports nested field access**
- Automatically infers type and size
- Most concise code

**Usage Example**:

```c
struct task_struct *task = (struct task_struct *)bpf_get_current_task();

// Read single field
pid_t pid = BPF_CORE_READ(task, pid);

// Read nested field - One line! âœ…
pid_t ppid = BPF_CORE_READ(task, real_parent, pid);
```

**Advantages**:

- âœ… Most concise code (nested access in one line)
- âœ… Type safe (compile-time checking)
- âœ… Automatic offset handling
- âœ… Full CO-RE support

**Applicable Scenarios**:

- **Reading kernel structure fields** (Recommended!)
- Need CO-RE support
- Want concise, readable code

#### Practical Comparison: Reading Parent Process PID

**Scenario**: Read `task->real_parent->pid`

##### Method 1: bpf_probe_read (Not Recommended)

```c
struct task_struct *task = (struct task_struct *)bpf_get_current_task();
struct task_struct *parent;
pid_t ppid;

// Need 3 steps, 8 lines of code
bpf_probe_read(&parent, sizeof(parent),
               (void *)task + offsetof(struct task_struct, real_parent));
bpf_probe_read(&ppid, sizeof(ppid),
               (void *)parent + offsetof(struct task_struct, pid));

// âŒ Problems:
// 1. Need to know offsetof, but offsetof may be inaccurate in eBPF
// 2. No CO-RE, cannot work across kernel versions
// 3. Verbose code, error-prone
```

##### Method 2: bpf_core_read (Usable, but Verbose)

```c
struct task_struct *task = (struct task_struct *)bpf_get_current_task();
struct task_struct *parent;
pid_t ppid;

// Need 2 steps, 5 lines of code
bpf_core_read(&parent, sizeof(parent), &task->real_parent);  // âœ… CO-RE
bpf_core_read(&ppid, sizeof(ppid), &parent->pid);            // âœ… CO-RE

// âš ï¸ Drawbacks:
// 1. Need intermediate variable parent
// 2. Need two function calls
// 3. Manual size specification
```

##### Method 3: BPF_CORE_READ (Recommended!) â­â­â­â­â­

```c
struct task_struct *task = (struct task_struct *)bpf_get_current_task();

// Only need 1 line! âœ…
pid_t ppid = BPF_CORE_READ(task, real_parent, pid);

// âœ… Advantages:
// 1. Concise and clear code
// 2. Full CO-RE support
// 3. Automatic type and size handling
// 4. Nested access in one call
```

#### Common Misconceptions

##### Misconception 1: Confusing bpf_core_read Function and BPF_CORE_READ Macro

```c
// âŒ Wrong: Using macro as function
bpf_core_read(&ppid, sizeof(ppid), task->real_parent->pid);  // Compilation error!

// âœ… Correct: Use macro
pid_t ppid = BPF_CORE_READ(task, real_parent, pid);
```

##### Misconception 2: Directly Accessing Nested Fields in bpf_core_read

```c
// âŒ Wrong: bpf_core_read doesn't support nested access
pid_t ppid;
bpf_core_read(&ppid, sizeof(ppid), &task->real_parent->pid);  // âŒ

// âœ… Correct: Use BPF_CORE_READ macro
pid_t ppid = BPF_CORE_READ(task, real_parent, pid);  // âœ…
```

##### Misconception 3: Using BPF_CORE_READ Where bpf_probe_read_user Should Be Used

```c
// âŒ Wrong: BPF_CORE_READ is for kernel structures, cannot read user-space memory
char *user_str = "user space string";
char buf[64];
// BPF_CORE_READ(buf, user_str);  // âŒ Wrong!

// âœ… Correct: Use bpf_probe_read_user_str to read user-space strings
bpf_probe_read_user_str(buf, sizeof(buf), user_str);  // âœ…
```

#### Selection Guide

**Decision Tree**:

```
Need to read memory data
  â”‚
  â”œâ”€ Reading user-space memory?
  â”‚   â””â”€ Yes â†’ Use bpf_probe_read_user / bpf_probe_read_user_str
  â”‚
  â””â”€ Reading kernel structures?
      â”‚
      â”œâ”€ Need CO-RE support?
      â”‚   â”œâ”€ No â†’ Use bpf_probe_read (not recommended unless special reason)
      â”‚   â””â”€ Yes â†“
      â”‚
      â”œâ”€ Accessing nested fields?
      â”‚   â”œâ”€ Yes â†’ Use BPF_CORE_READ macro â­â­â­â­â­ (Recommended!)
      â”‚   â””â”€ No  â†’ Use bpf_core_read or BPF_CORE_READ
      â”‚
      â””â”€ Conclusion: Default to BPF_CORE_READ macro!
```

#### Best Practice Recommendations

1. **Prefer BPF_CORE_READ macro**
2. **Avoid using bpf_probe_read to read kernel structures**
   - Only use for reading user-space memory
   - Or in scenarios that completely don't need CO-RE
3. **bpf_core_read function has few use cases**
   - Only use when special control is needed
   - In most cases, BPF_CORE_READ macro is sufficient

### 4. Common Incorrect Usage Comparison

#### Error Example 1: Direct Pointer Access

```c
// âŒ Wrong: Direct access (will cause verifier failure)
struct task_struct *task = (struct task_struct *)bpf_get_current_task();
pid_t ppid = task->real_parent->pid;  // Verifier error!
```

**Error Reason**:

- eBPF verifier cannot verify pointer validity
- Different kernel versions have different offsets

#### Error Example 2: Using bpf_probe_read

```c
// âŒ Not recommended: Using bpf_probe_read (can work, but not best practice)
struct task_struct *task = (struct task_struct *)bpf_get_current_task();
struct task_struct *parent;
pid_t ppid;

bpf_probe_read(&parent, sizeof(parent), &task->real_parent);
bpf_probe_read(&ppid, sizeof(ppid), &parent->pid);
```

**Problems**:

- Verbose code
- No CO-RE portability
- Need to manually handle each level of pointer

#### Correct Example

```c
// âœ… Correct: Use BPF_CORE_READ
struct task_struct *task = (struct task_struct *)bpf_get_current_task();
pid_t ppid = BPF_CORE_READ(task, real_parent, pid);

// âœ… Better: Use bpf_get_current_task_btf()
struct task_struct *task = (struct task_struct *)bpf_get_current_task_btf();
pid_t ppid = BPF_CORE_READ(task, real_parent, pid);
```

## 2.6 bpf_get_current_task_btf() Function

This is a helper function that returns a **BTF-typed pointer**, safer than `bpf_get_current_task()`.

#### Comparison of Two Ways to Get task_struct

| Method | Function | Return Type | Type Safety | Recommendation |
|------|------|---------|---------|--------|
| Traditional way | `bpf_get_current_task()` | `void *` (requires casting) | âŒ Weak | Not recommended |
| BTF way | `bpf_get_current_task_btf()` | `struct task_struct *` | âœ… Strong | **Recommended** |

#### Usage Example

```c
// Method 1: Traditional way
struct task_struct *task = (struct task_struct *)bpf_get_current_task();
pid_t ppid = BPF_CORE_READ(task, real_parent, pid);

// Method 2: BTF way (Recommended)
struct task_struct *task = (struct task_struct *)bpf_get_current_task_btf();
pid_t ppid = BPF_CORE_READ(task, real_parent, pid);
```

**Key Differences**:

- `bpf_get_current_task_btf()` returns a pointer **carrying BTF type information**
- eBPF verifier can perform stricter type checking
- Better error messages and debugging experience

# 3. Practical Example: Monitoring open System Call

### Complete eBPF Kernel Program

**File: `btf.bpf.c`**

```c
// Example code would go here
```

### User-Space Program

**File: `btf.c`**

```c
// Example code would go here
```

# 4. Common Questions

### Q1: What's the relationship between BTF and CO-RE?

**Answer**:
- **BTF**: Type metadata format (data format)
- **CO-RE**: Compile Once, Run Everywhere technology (application using BTF)
- Relationship: CO-RE depends on type information provided by BTF

### Q2: Do all kernels support BTF?

**Answer**: No, the following conditions must be met:
- Linux kernel >= 5.2 (BTF support)
- Kernel compiled with `CONFIG_DEBUG_INFO_BTF=y` enabled
- Check method: `ls /sys/kernel/btf/vmlinux`

### Q3: What's the difference between bpf_probe_read, bpf_core_read, and BPF_CORE_READ?

**Answer**: These three are different ways to read memory data in eBPF. For detailed comparison, please refer to [Section 2.5](#25-bpf_probe_read-vs-bpf_core_read-vs-bpf_core_read-detailed-explanation).

**Quick Summary**:

| Feature | bpf_probe_read | bpf_core_read | BPF_CORE_READ |
|------|----------------|---------------|---------------|
| Type | Function | Function | Macro |
| CO-RE Support | âŒ No | âœ… Yes | âœ… Yes |
| Nested Access | âŒ Need multiple calls | âŒ Need multiple calls | âœ… One line |
| Type Safety | âŒ Weak | âœ… Strong | âœ… Strong |
| Recommendation | â­â­ | â­â­â­ | â­â­â­â­â­ |

**Decision Guide**:
- ðŸ¥‡ **Prefer BPF_CORE_READ macro**: Read kernel structure fields (especially nested fields)
- ðŸ¥ˆ **Occasionally use bpf_core_read function**: Single field and need special control
- ðŸ¥‰ **Avoid bpf_probe_read**: Only for reading user-space memory or scenarios that completely don't need CO-RE

**Example**:
```c
// â­â­â­â­â­ Recommended: BPF_CORE_READ macro
pid_t ppid = BPF_CORE_READ(task, real_parent, pid);  // One line!

// â­â­â­ Usable: bpf_core_read function
bpf_core_read(&parent, sizeof(parent), &task->real_parent);
bpf_core_read(&ppid, sizeof(ppid), &parent->pid);  // Need two steps

// â­â­ Not recommended: bpf_probe_read
bpf_probe_read(&parent, sizeof(parent), &task->real_parent);
bpf_probe_read(&ppid, sizeof(ppid), &parent->pid);  // No CO-RE
```

### Q4: Why sometimes use bpf_get_current_task(), and sometimes bpf_get_current_task_btf()?

**Answer**:

| Function | Return Type | Kernel Requirement | Recommendation |
|------|---------|---------|--------|
| `bpf_get_current_task()` | `unsigned long` (requires casting) | All versions | High compatibility |
| `bpf_get_current_task_btf()` | `struct task_struct *` | >= 5.14 | **Type safe** |

**Recommendation**:
- If only supporting new kernels (>= 5.14): Use `bpf_get_current_task_btf()`
- If need to support old kernels: Use `bpf_get_current_task()` + casting
